parameters:
  keyvaultName: ''
  serviceConnection: ''
  helmVersion: ''
  location: ''
  acrName: ''
  fluxGithubKeySecureFileName: ''
  monInfraAppName: ''
  monInfraSlackChannel: ''
  monInfraAgName: ''
  monInfraAgShortName: ''
  monInfraRg: ''
  metricAlertsEnabled: ''
  customAlertsEnabled: ''
  aksClusterName: ''
  aksVnetName: ''
  aksKubernetesVersion: ''
  aksVmSize: ''
  aksNodeCount: ''
  aksDnsPrefix: ''
  aksSshPublicKey: ''
  aksServicePrincipalId: ''
  aksClientAppId: ''
  aksServerAppId: ''
  aksTenantId: ''

jobs:
- job: Keyvault
  pool:
    vmImage: 'Ubuntu 16.04'
    #name: hmcts-agent-pool #TODO: change to hosted when merged
  steps:
  - task: AzureKeyVault@1
    displayName: 'Get secrets from Keyvault'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      keyVaultName: ${{ parameters.keyvaultName }}
      secretsFilter: 'aks-sp-id,aks-sp-secret,aks-sapp-secret,slack-webhook-url'
  - script: |
      echo "##vso[task.setvariable variable=aksServicePrincipalId;isOutput=true]$(aks-sp-id)"
      echo "##vso[task.setvariable variable=aksServicePrincipalSecret;isOutput=true]$(aks-sp-secret)"
      echo "##vso[task.setvariable variable=aksServerAppSecret;isOutput=true]$(aks-sapp-secret)"
      echo "##vso[task.setvariable variable=slackWebhookUrl;isOutput=true]$(slack-webhook-url)"
    displayName: 'Export Keyvault Variables'
    name: exportKeyvault

- job: MonitoringDeploy
  displayName: Deploy Monitoring Infra
  pool:
    vmImage: 'Ubuntu 16.04'
    #name: hmcts-agent-pool #TODO: change to hosted when merged
  variables:
    - group: aks-variable-group
  steps:
  - task: AzureResourceGroupDeployment@2
    displayName: 'Deploy Monitoring Infrastructure'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      action: 'Create Or Update Resource Group'
      resourceGroupName: ${{ parameters.monInfraRg }}
      deploymentMode: 'Incremental'
      location: ${{ parameters.location }}
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-mon-infra.json'
      overrideParameters: '-logicAppName "${{ parameters.monInfraAppName }}"
        -slackUri "$(slackUriSecureVariable)"
        -slackChannel "${{ parameters.monInfraSlackChannel }}"
        -agName "${{ parameters.monInfraAgName }}"
        -agShortName "${{ parameters.monInfraAgShortName }}"
        -agEmailReceivers "$(monInfraAgEmailReceivers)"'
      deploymentOutputs: 'monInfraOutputs'

  - task: Bash@3
    displayName: Parse ARM Outputs
    #condition: not(variables['aksSubnetId'])
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        for row in $(echo '$(monInfraOutputs)' | jq -c '. | to_entries[]'); do
          outputName=$(echo ${row} | jq -r ".key")
          outputValue=$(echo ${row} | jq -r ".value.value")
          echo "##vso[task.setvariable variable=${outputName}]${outputValue}"
        done
  - script: |
      echo "##vso[task.setvariable variable=outActionGroupID;isOutput=true]$(actionGroupID)"
    name: exportActionGroupID

- job: DeployAKS
  dependsOn: 
    - Keyvault
  pool:
    vmImage: 'Ubuntu 16.04'
    #name: hmcts-agent-pool #TODO: change to hosted when merged
  variables:
    - group: aks-variable-group
    - name: aksServicePrincipalId
      value: $[dependencies.Keyvault.outputs['exportKeyvault.aksServicePrincipalId']]
    - name: aksServicePrincipalSecret
      value: $[dependencies.Keyvault.outputs['exportKeyvault.aksServicePrincipalSecret']]
    - name: aksServerAppSecret
      value: $[dependencies.Keyvault.outputs['exportKeyvault.aksServerAppSecret']]
    - name: slackWebhookUrl
      value: $[dependencies.Keyvault.outputs['exportKeyvault.slackWebhookUrl']]
  steps:

  - task: AzureCLI@1
    displayName: Check VNET prerequisites
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      arguments: $(aksResourceGroup) $(aksVnetCidr) $(aksSubnetCidr)
      scriptPath: scripts/check-vnet-prerequisites.sh

  - task: AzureResourceGroupDeployment@2
    displayName: 'Deploy VNET'
    condition: not(variables['aksSubnetId'])
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      action: 'Create Or Update Resource Group'
      resourceGroupName: $(aksResourceGroup)
      deploymentMode: 'Incremental'
      location: ${{ parameters.location }}
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-vnet-template.json'
      overrideParameters: '-aksVnetName ${{ parameters.aksClusterName }} 
        -aksVnetPrefix $(aksVnetCidr) 
        -aksSubnetName default 
        -aksSubnetPrefix $(aksSubnetCidr)'
      deploymentOutputs: 'vnetOutputs'

  - task: Bash@3
    displayName: Parse ARM Outputs
    condition: not(variables['aksSubnetId'])
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        for row in $(echo '$(vnetOutputs)' | jq -c '. | to_entries[]'); do
          outputName=$(echo ${row} | jq -r ".key")
          outputValue=$(echo ${row} | jq -r ".value.value")
          echo "##vso[task.setvariable variable=${outputName}]${outputValue}"
        done

  - task: AzureResourceGroupDeployment@2
    displayName: 'Deploy AKS Cluster'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      action: 'Create Or Update Resource Group'
      resourceGroupName: $(aksResourceGroup)
      deploymentMode: 'Incremental'
      location: ${{ parameters.location }}
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-aks-template.json'
      csmParametersFile: 'templates/arm-aks-parameters.json'
      overrideParameters: '-aksClusterName ${{ parameters.aksClusterName }} 
        -aksVnetSubnetId $(aksSubnetId) 
        -aksServiceCidr $(aksServiceCidr) 
        -aksDnsServiceIp $(aksDnsServiceIp)
        -servicePrincipalSecret $(aksServicePrincipalSecret) 
        -serverAppSecret $(aksServerAppSecret)
        -kubernetesVersion ${{ parameters.aksKubernetesVersion }}
        -vmSize ${{ parameters.aksVmSize }}
        -nodeCount ${{ parameters.aksNodeCount }}
        -dnsPrefix ${{ parameters.aksDnsPrefix }}
        -sshPublicKey "${{ parameters.aksSshPublicKey }}"
        -servicePrincipalId ${{ parameters.aksServicePrincipalId }}
        -clientAppId ${{ parameters.aksClientAppId }}
        -serverAppId ${{ parameters.aksServerAppId }}
        -tenantId ${{ parameters.aksTenantId }}
        -aksLogAnalyticsId $(workspaceID)'
      deploymentOutputs: 'aksOutputs'

  - task: Bash@3
    displayName: Parse ARM Outputs
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        for row in $(echo '$(aksOutputs)' | jq -c '. | to_entries[]'); do
          outputName=$(echo ${row} | jq -r ".key")
          outputValue=$(echo ${row} | jq -r ".value.value")
          echo "##vso[task.setvariable variable=${outputName}]${outputValue}"
        done      
  - script: |
      echo "##vso[task.setvariable variable=outAksID;isOutput=true]$(aksID)"
    name: exportAksID

  - task: AzureCLI@1
    displayName: 'Obtain AKS Admin access token.'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      scriptLocation: 'inlineScript'
      inlineScript: |
        az aks get-credentials --resource-group $(aksResourceGroup) --name ${{ parameters.aksClusterName }} --admin --overwrite-existing

  - task: AzureCLI@1
    displayName: 'Enable Diagnostics Settings'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      scriptLocation: 'inlineScript'
      inlineScript: |
        az monitor diagnostic-settings create \
            -n DiagLogAnalytics \
            --resource $(aksID) \
            --workspace $(workspaceID) \
            --logs '[{"category":"kube-apiserver","Enabled":true},{"category":"kube-controller-manager","Enabled":true},{"category":"cluster-autoscaler","Enabled":true},{"category":"kube-scheduler","Enabled":true},{"category":"kube-audit","Enabled":true}]' \
            --metrics '[{"category":"AllMetrics","enabled":true,"retentionPolicy":{"days":30,"enabled":true}}]'

  - task: Bash@3
    displayName: 'Create Custom Namespaces'
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        kubectl apply -f deployments/namespaces.yaml

  - task: AzureCLI@1
    displayName: 'Bind admin role to "aks-cluster-admin" group'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      scriptLocation: 'inlineScript'
      inlineScript: |
        CLUSTER_GLOBAL_ADMINS_GROUP=$(az ad group list --query  "[?displayName=='aks-cluster-admins'].objectId" -o tsv)
        
        CLUSTER_ADMINS_GROUP_NAME="${{ parameters.aksClusterName }}-cluster-admins"
        CLUSTER_ADMIN_GROUP=$(az ad group list --query  "[?displayName=='${CLUSTER_ADMINS_GROUP_NAME}'].objectId" -o tsv)
        if [ -z "${CLUSTER_ADMIN_GROUP}" ]; then 
            echo "Cluster admin group doesn't exist, creating"
            CLUSTER_ADMIN_GROUP=$(az ad group create  --display-name ${CLUSTER_ADMINS_GROUP_NAME} --mail-nickname ${CLUSTER_ADMINS_GROUP_NAME} --query objectId -o tsv)
        fi
        
        cat roles/cluster-admin-role-binding.yaml | \
          sed -e 's@${CLUSTER_ADMIN_GROUP}@'"$CLUSTER_ADMIN_GROUP"'@' | \
          sed -e 's@${CLUSTER_GLOBAL_ADMINS_GROUP}@'"$CLUSTER_GLOBAL_ADMINS_GROUP"'@' | \
          kubectl apply -f -

  - task: AzureCLI@1
    displayName: 'Bind developers roles'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      scriptLocation: 'inlineScript'
      inlineScript: |
        kubectl apply -f roles/developers-log-reader-role.yaml
        DEVELOPERS_GROUP=$(az ad group list --query  "[?displayName=='developers'].objectId" -o tsv)
        if [ ! -z "${DEVELOPERS_GROUP}" ]; then          
          cat roles/developers-log-reader-binding.yaml | sed -e 's@${DEVELOPERS_GROUP}@'"$DEVELOPERS_GROUP"'@' | kubectl apply -f -
        fi

  - task: AzureResourceGroupDeployment@2
    displayName: 'Create Managed Identity for AKS'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      action: 'Create Or Update Resource Group'
      resourceGroupName: $(aksResourceGroup)
      deploymentMode: 'Incremental'
      location: ${{ parameters.location }}
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-mi-template.json'
      overrideParameters: '-resourceName ${{ parameters.aksClusterName }}-mi'
      deploymentOutputs: 'miOutputs'

  - task: Bash@3
    displayName: Parse ARM Outputs
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        for row in $(echo '$(miOutputs)' | jq -c '. | to_entries[]'); do
          outputName=$(echo ${row} | jq -r ".key")
          outputValue=$(echo ${row} | jq -r ".value.value")
          echo "##vso[task.setvariable variable=${outputName}]${outputValue}"
        done

  - task: AzureCLI@1
    displayName: 'Permissions MI to Key Vault ${{ parameters.keyvaultName }}'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      scriptLocation: 'inlineScript'
      inlineScript: |
        az keyvault set-policy -n ${{ parameters.keyvaultName }} --object-id $(miPrincipalID) --secret-permissions get list --certificate-permissions get list --key-permissions get list

  - task: HelmInstaller@0
    displayName: 'Helm - Install Client ${{ parameters.helmVersion }}'
    inputs:
        helmVersion: ${{ parameters.helmVersion }}
        checkLatestHelmVersion: false
        installKubectl: false

  - task: Bash@3
    displayName: 'Helm - Install Tiller ${{ parameters.helmVersion }}'
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        kubectl apply -f roles/helm-rbac-config.yaml
        helm init --wait --service-account tiller --tiller-image gcr.io/kubernetes-helm/tiller:v${{ parameters.helmVersion }} --history-max=5 --kube-context '${{ parameters.aksClusterName }}-admin'

  - task: Bash@3
    displayName: 'Kured - Template secret'
    inputs:
      targetType: inline
      failOnStderr: true
      script: |
        sed -i -e 's@${SLACK_WEBHOOK_URL}@'"$SLACK_WEBHOOK_URL"'@' templates/kured/values.yaml
        sed -i -e 's@${SLACK_USERNAME}@'"$SLACK_USERNAME"'@' templates/kured/values.yaml
    env:
      SLACK_WEBHOOK_URL: $(slackWebhookUrl)
      SLACK_USERNAME: ${{ parameters.aksClusterName }}

  - task: Bash@3
    displayName: 'Kured - Create secret'
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        kubectl -n admin delete secret kured-values || true
        kubectl -n admin create secret generic kured-values --from-file=templates/kured/values.yaml

  - task: Bash@3
    displayName: 'Flux - Template repositories.yaml secret'
    inputs:
      targetType: inline
      failOnStderr: true
      script: |
        sed -i -e 's/${ACR_NAME}/${{ parameters.acrName }}/g' \
               -e 's@${ACR_SERVICE_PRINCIPAL_ID}@'"$AKS_SP_ID"'@' \
               -e 's@${ACR_SERVICE_PRINCIPAL_SECRET}@'"$AKS_SP_SECRET"'@' \
          templates/repositories.yaml
    env:
      AKS_SP_ID: $(aksServicePrincipalId)
      AKS_SP_SECRET: $(aksServicePrincipalSecret)

  - task: Bash@3
    displayName: 'Flux - Create repositories.yaml secret'
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        kubectl -n admin delete secret flux-helm-repositories || true
        kubectl -n admin create secret generic flux-helm-repositories --from-file=templates/repositories.yaml

  - task: Bash@3
    displayName: 'Flux - Install'
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        helm repo add weaveworks https://weaveworks.github.io/flux
        helm upgrade flux weaveworks/flux --install --namespace admin -f deployments/weave-flux/values.yaml \
          --set "git.path=k8s/${{ parameters.aksClusterName }}\,k8s/common",git.label=${{ parameters.aksClusterName }} \
          --wait

  - task: DownloadSecureFile@1
    displayName: 'Flux - Download Github Key'
    inputs:
      secureFile: ${{ parameters.fluxGithubKeySecureFileName }}

  - task: Bash@3
    displayName: 'Flux - Create Github Key Secret'
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        kubectl -n admin delete secret flux-git-deploy || true
        kubectl apply -f $(Agent.TempDirectory)/${{ parameters.fluxGithubKeySecureFileName }}
        kubectl -n admin delete $(kubectl get pod -o name -l app=flux -n admin)

- job: MonitoringAddAlerts
  displayName: Deploy Alerts
  dependsOn: 
    - Keyvault
    - DeployAKS
    - MonitoringDeploy
  pool:
    vmImage: 'Ubuntu 16.04'
    #name: hmcts-agent-pool #TODO: change to hosted when merged
  variables:
    - group: aks-variable-group  
    - name: outActionGroupID
      value: $[dependencies.MonitoringDeploy.outputs['exportActionGroupID.outActionGroupID']]
    - name: outAksID
      value: $[dependencies.DeployAKS.outputs['exportAksID.outAksID']]
  steps:

  - task: AzureResourceGroupDeployment@2
    displayName: 'Add Metric Alerts'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      action: 'Create Or Update Resource Group'
      resourceGroupName: $(aksResourceGroup)
      deploymentMode: 'Incremental'
      location: ${{ parameters.location }}
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-mon-metric-alerts.json'
      overrideParameters: '-aksName ${{ parameters.aksClusterName }} 
        -isEnabled ${{ parameters.metricAlertsEnabled }} 
        -resourceId $(outAksID) 
        -actionGroupId $(outActionGroupID)'

  - task: AzureResourceGroupDeployment@2
    displayName: 'Add Custom Search Alerts'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      action: 'Create Or Update Resource Group'
      resourceGroupName: $(aksResourceGroup)
      deploymentMode: 'Incremental'
      location: ${{ parameters.location }}
      templateLocation: 'Linked artifact'
      csmFile: 'templates/arm-mon-custom-alerts.json'
      overrideParameters: '-aksName ${{ parameters.aksClusterName }} 
        -isEnabled ${{ parameters.metricAlertsEnabled }} 
        -resourceId $(workspaceID)
        -actionGroupId $(outActionGroupID)'

- job: RunTests
  dependsOn: DeployAKS
  pool:
    vmImage: 'Ubuntu 16.04'
    #name: hmcts-agent-pool #TODO: change to hosted when merged
  steps:
  - task: AzureCLI@1
    displayName: 'Obtain AKS Admin access token.'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      scriptLocation: 'inlineScript'
      inlineScript: |
        az aks get-credentials --resource-group $(aksResourceGroup) --name ${{ parameters.aksClusterName }} --admin --overwrite-existing

  - task: DownloadSecureFile@1
    displayName: 'Download test developer'
    inputs:
      secureFile: test-developer.json
  
  - task: Bash@3
    displayName: 'Install Chrome'
    inputs:
      targetType: inline
      failOnStderr: false
      script: |
        $(Build.SourcesDirectory)/tests/interactive-login-bypasser/install-chrome.sh

  - task: AzureCLI@1
    displayName: 'Run tests'
    inputs:
      azureSubscription: ${{ parameters.serviceConnection }}
      scriptLocation: 'inlineScript'
      addSpnToEnvironment: true
      inlineScript:
        pwsh -Command "\$userPwd = ConvertTo-SecureString -String \$env:servicePrincipalKey -AsPlainText -Force; Write-Host \$usrPwd; \$cred = New-Object System.Management.Automation.PSCredential (\$env:servicePrincipalId, \$userPwd); Install-Module Az -Force  -Scope CurrentUser; Enable-AzureRmAlias; Connect-AzAccount -ServicePrincipal -Credential \$cred -TenantId a0d77fc4-df1e-4b0d-8e35-46750ca5a672; Install-Module Pester -Force -Scope CurrentUser; Invoke-Pester @{Path= '$(Build.SourcesDirectory)/tests/*.tests.ps1' ;Parameters = @{ResourceGroupName='$(aksResourceGroup)';AgentTempDirectory='$(Agent.TempDirectory)'}} -OutputFile $(Build.SourcesDirectory)/Tests-RESULTS.xml -OutputFormat NUnitXML -EnableExit"
      
  - task: PublishTestResults@2
    displayName: 'Publish Environment Test Results **/TEST-*.xml'
    condition: always()
    inputs:
      testResultsFormat: NUnit
      timeoutInMinutes: 1